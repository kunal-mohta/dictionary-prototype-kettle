diff --git a/src/components/reorderer/js/ModuleLayout.js b/src/components/reorderer/js/ModuleLayout.js
index 077504a..5e90ca6 100644
--- a/src/components/reorderer/js/ModuleLayout.js
+++ b/src/components/reorderer/js/ModuleLayout.js
@@ -204,6 +204,11 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
             columns: "{reorderer}.options.selectors.columns"
         },
         distributeOptions: {
+        // TODO: We will have to forbid this kind of clever junk in time. It should properly be done with an 
+        // "upward distribution of grade" which we will have to forbid. Therefore the proper scheme for doing
+        // this is with some kind of "reactive distribution" which broadcasts to {/ fluid.reorderer > fluid.moduleLayoutHandler}
+        // Well... can we really do this? It actually seems prohibitive compared to actually permitting upward grade distribution.
+        // This implies we should eagerly evaluate all options distributions everywhere.
             target: "{reorderer}.options",
             record: {
                 selectors: {
diff --git a/src/framework/core/js/Fluid.js b/src/framework/core/js/Fluid.js
index c99b41a..f1aeb92 100644
--- a/src/framework/core/js/Fluid.js
+++ b/src/framework/core/js/Fluid.js
@@ -267,6 +267,7 @@ var fluid = fluid || fluid_3_0_0;
     fluid.setLogLevel = fluid.setLogging;
 
     /** Undo the effect of the most recent "setLogging", returning the logging system to its previous state **/
+    // TODO: This function is documented, but untested
     fluid.popLogging = function () {
         var togo = logLevelStack.length === 1 ? logLevelStack[0] : logLevelStack.shift();
         fluid.defeatLogging = !fluid.isLogging();
@@ -999,6 +1000,7 @@ var fluid = fluid || fluid_3_0_0;
     fluid.model.resolvePathSegment = function (root, segment, create, origEnv) {
         // TODO: This branch incurs a huge cost that we incur across the whole framework, just to support the DOM binder
         // usage. We need to either do something "schematic" or move to proxies
+        // TODO: Most costs are incurred from fluid.compileMergePolicy, some from fluid.model.setChangedPath
         if (!origEnv && root.resolvePathSegment) {
             var togo = root.resolvePathSegment(segment);
             if (togo !== undefined) { // To resolve FLUID-6132
@@ -1667,13 +1669,6 @@ var fluid = fluid || fluid_3_0_0;
         return errors;
     };
 
-    /** Removes duplicated and empty elements from an already sorted array **/
-    fluid.unique = function (array) {
-        return fluid.remove_if(array, function (element, i) {
-            return !element || i > 0 && element === array[i - 1];
-        });
-    };
-
     fluid.arrayConcatPolicy = function (target, source) {
         return fluid.makeArray(target).concat(fluid.makeArray(source));
     };
@@ -1685,24 +1680,6 @@ var fluid = fluid || fluid_3_0_0;
     fluid.failureEvent.addListener(fluid.builtinFail, "fail");
     fluid.failureEvent.addListener(fluid.logFailure, "log", "before:fail");
 
-    /**
-     * Configure the behaviour of fluid.fail by pushing or popping a disposition record onto a stack.
-     * @param {Number|Function} condition
-     & Supply either a function, which will be called with two arguments, args (the complete arguments to
-     * fluid.fail) and activity, an array of strings describing the current framework invocation state.
-     * Or, the argument may be the number <code>-1</code> indicating that the previously supplied disposition should
-     * be popped off the stack
-     */
-    fluid.pushSoftFailure = function (condition) {
-        if (typeof (condition) === "function") {
-            fluid.failureEvent.addListener(condition, "fail");
-        } else if (condition === -1) {
-            fluid.failureEvent.removeListener("fail");
-        } else if (typeof(condition) === "boolean") {
-            fluid.fail("pushSoftFailure with boolean value is no longer supported");
-        }
-    };
-
     /*** DEFAULTS AND OPTIONS MERGING SYSTEM ***/
 
     // A function to tag the types of all Fluid components
@@ -1713,10 +1690,10 @@ var fluid = fluid || fluid_3_0_0;
     // No longer a publically supported function - we don't abolish this because it is too annoying to prevent
     // circularity during the bootup of the IoC system if we try to construct full components before it is complete
     // unsupported, non-API function
-    fluid.typeTag = function (name) {
+    fluid.typeTag = function (type, id) {
         var that = Object.create(fluid.componentConstructor.prototype);
-        that.typeName = name;
-        that.id = fluid.allocateGuid();
+        that.typeName = type;
+        that.id = id || fluid.allocateGuid();
         return that;
     };
 
@@ -1804,7 +1781,7 @@ var fluid = fluid || fluid_3_0_0;
         var mergedDefaults = fluid.mergedDefaultsCache[key];
         if (mergedDefaults) {
             var lastTick = 0; // check if cache should be invalidated through real latest tick being later than the one stored
-            var searchGrades = mergedDefaults.defaults.gradeNames || [];
+            var searchGrades = mergedDefaults.defaults.gradeNames;
             for (var i = 0; i < searchGrades.length; ++i) {
                 lastTick = Math.max(lastTick, gradeTickStore[searchGrades[i]] || 0);
             }
@@ -1941,30 +1918,32 @@ var fluid = fluid || fluid_3_0_0;
         }
     };
 
-    fluid.makeComponentCreator = function (componentName) {
-        var creator = function () {
-            var defaults = fluid.getMergedDefaults(componentName);
-            if (!defaults.gradeNames || defaults.gradeNames.length === 0) {
-                fluid.fail("Cannot make component creator for type " + componentName + " which does not have any gradeNames defined");
-            } else if (!defaults.initFunction) {
-                var blankGrades = [];
-                for (var i = 0; i < defaults.gradeNames.length; ++i) {
-                    var gradeName = defaults.gradeNames[i];
-                    var rawDefaults = fluid.rawDefaults(gradeName);
-                    if (!rawDefaults) {
-                        blankGrades.push(gradeName);
-                    }
+    fluid.validateCreatorGrade = function (message, componentName) {
+        var defaults = fluid.getMergedDefaults(componentName);
+        if (!defaults.gradeNames || defaults.gradeNames.length === 0) {
+            fluid.fail(message + " type " + componentName + " which does not have any gradeNames defined");
+        } else if (!defaults.argumentMap) {
+            var blankGrades = [];
+            for (var i = 0; i < defaults.gradeNames.length; ++i) {
+                var gradeName = defaults.gradeNames[i];
+                var rawDefaults = fluid.rawDefaults(gradeName);
+                if (!rawDefaults) {
+                    blankGrades.push(gradeName);
                 }
-                if (blankGrades.length === 0) {
-                    fluid.fail("Cannot make component creator for type " + componentName + " which does not have an initFunction defined");
-                } else {
-                    fluid.fail("The grade hierarchy of component with type " + componentName + " is incomplete - it inherits from the following grade(s): " +
-                     blankGrades.join(", ") + " for which the grade definitions are corrupt or missing. Please check the files which might include these " +
-                     "grades and ensure they are readable and have been loaded by this instance of Infusion");
-                }
-            } else {
-                return fluid.initComponent(componentName, arguments);
             }
+            if (blankGrades.length === 0) {
+                fluid.fail(message + " type " + componentName + " which is not derived from fluid.component");
+            } else {
+                fluid.fail("The grade hierarchy of component with type " + componentName + " is incomplete - it inherits from the following grade(s): " +
+                 blankGrades.join(", ") + " for which the grade definitions are corrupt or missing. Please check the files which might include these " +
+                 "grades and ensure they are readable and have been loaded by this instance of Infusion");
+            }  
+    };
+
+    fluid.makeComponentCreator = function (componentName) {
+        var creator = function () {
+            fluid.validateCreatorGrade("Cannot make component creator for", componentName);
+            return fluid.initFreeComponent(componentName, arguments);
         };
         var existing = fluid.getGlobalValue(componentName);
         if (existing) {
@@ -2364,27 +2343,19 @@ var fluid = fluid || fluid_3_0_0;
      * Merges the component's declared defaults, as obtained from fluid.defaults(),
      * with the user's specified overrides.
      *
-     * @param {Object} that the instance to attach the options to
-     * @param {String} componentName the unique "name" of the component, which will be used
-     * to fetch the default options from store. By recommendation, this should be the global
-     * name of the component's creator function.
-     * @param {Object} userOptions the user-specified configuration options for this component
+     * @param that {Object} the instance to attach the options to
+     * @param potentia {Object} The potentia record supplied for this construction
      */
+     // TODO: Will have to accept multiple potentiae
     // unsupported, NON-API function
-    fluid.mergeComponentOptions = function (that, componentName, userOptions, localOptions) {
-        var rawDefaults = fluid.rawDefaults(componentName);
-        var defaults = fluid.getMergedDefaults(componentName, rawDefaults && rawDefaults.gradeNames ? null : localOptions.gradeNames);
+    fluid.mergeComponentOptions = function (that, potentia, lightMerge) {
+        fluid.validateCreatorGrade("Cannot construct component of", lightMerge.type);
+        var defaults = fluid.getMergedDefaults(lightMerge.type);
         var sharedMergePolicy = {};
 
-        var mergeBlocks = [];
+        // FROM HERE we notify the instantiator, fabricate destroy, etc.
+        var mergeBlocks = fluid.expandComponentOptions(sharedMergePolicy, defaults, potentia, lightMerge, that);
 
-        if (fluid.expandComponentOptions) {
-            mergeBlocks = mergeBlocks.concat(fluid.expandComponentOptions(sharedMergePolicy, defaults, userOptions, that));
-        }
-        else {
-            mergeBlocks = mergeBlocks.concat([fluid.simpleGingerBlock(defaults, "defaults"),
-                                              fluid.simpleGingerBlock(userOptions, "user")]);
-        }
         var options = {}; // ultimate target
         var sourceStrategies = [], sources = [];
         var baseMergeOptions = {
@@ -2434,17 +2405,12 @@ var fluid = fluid || fluid_3_0_0;
         mergeOptions.computeMergePolicy = computeMergePolicy;
 
         if (compiledPolicy.hasDefaults) {
-            if (fluid.generateExpandBlock) {
-                mergeBlocks.push(fluid.generateExpandBlock({
-                    options: compiledPolicy.defaultValues,
-                    recordType: "defaultValueMerge",
-                    priority: fluid.mergeRecordTypes.defaultValueMerge
-                }, that, {}));
-                updateBlocks();
-            }
-            else {
-                fluid.fail("Cannot operate mergePolicy ", mergePolicy, " for component ", that, " without including FluidIoC.js");
-            }
+            mergeBlocks.push(fluid.generateExpandBlock({
+                options: compiledPolicy.defaultValues,
+                recordType: "defaultValueMerge",
+                priority: fluid.mergeRecordTypes.defaultValueMerge
+            }, that, {}));
+            updateBlocks();
         }
         that.options = options;
         fluid.driveStrategy(options, "gradeNames", mergeOptions.strategy);
@@ -2582,7 +2548,6 @@ var fluid = fluid || fluid_3_0_0;
     };
 
     fluid.defaults("fluid.component", {
-        initFunction: "fluid.initLittleComponent",
         mergePolicy: fluid.rootMergePolicy,
         argumentMap: {
             options: 0
@@ -2607,37 +2572,42 @@ var fluid = fluid || fluid_3_0_0;
         return segs[segs.length - 1];
     };
 
-    /** A specially recognised grade tag which directs the IoC framework to instantiate this component first amongst
-     * its set of siblings, since it is likely to bear a context-forming type name. This will be removed from the framework
-     * once we have implemented FLUID-4925 "wave of explosions" */
-
-    fluid.defaults("fluid.typeFount", {
-        gradeNames: ["fluid.component"]
-    });
-
     /**
-     * Creates a new "little component": a that-ist object with options merged into it by the framework.
-     * This method is a convenience for creating small objects that have options but don't require full
-     * View-like features such as the DOM Binder or events
+     * Creates the shell of a component, evaluating enough of its structure to determine its grade content but
+     * without creating events or (hopefully) any side-effects
      *
-     * @param {Object} name the name of the little component to create
-     * @param {Object} options user-supplied options to merge with the defaults
+     * @param potentia {Object} creation potentia for the component
      */
-    // NOTE: the 3rd argument localOptions is NOT to be advertised as part of the stable API, it is present
-    // just to allow backward compatibility whilst grade specifications are not mandatory - similarly for 4th arg "receiver"
-    // NOTE historical name to avoid confusion with fluid.initComponent below - this will all be refactored with FLUID-4925
-    fluid.initLittleComponent = function (name, userOptions, localOptions, receiver) {
-        var that = fluid.typeTag(name);
+    fluid.initComponentShell = function (potentia, mergeRecords, lightType) {
+        // Recall that this code used to be in fluid.assembleCreatorArguments
+        var upDefaults = fluid.defaults(lightType),
+            fakeThat = {};
+        var distributions = fluid.receiveDistributions(potentia.parentThat, upDefaults && upDefaults.gradeNames, potentia.memberName, fakeThat);
+        fluid.each(distributions, function (distribution) { // TODO: The duplicated route for this is in fluid.mergeComponentOptions
+            fluid.computeDistributionPriority(potentia.parentThat, distribution);
+            if (fluid.isPrimitive(distribution.priority)) { // TODO: These should be immutable and parsed just once on registration - but we can't because of crazy target-dependent distance system
+                distribution.priority = fluid.parsePriority(distribution.priority, 0, false, "options distribution");
+            }
+        });
+        // TODO: Which way up is this sort?
+        fluid.sortByPriority(distributions);
+        mergeRecords = mergeRecords.concat(distributions);
+        var lightMerge = fluid.lightMergeRecords(mergeRecords);     
+        var that = fluid.typeTag(lightMerge.type, potentia.record.id);
         that.lifecycleStatus = "constructing";
-        localOptions = localOptions || {gradeNames: "fluid.component"};
 
-        that.destroy = fluid.makeRootDestroy(that); // overwritten by FluidIoC for constructed subcomponents
-        var mergeOptions = fluid.mergeComponentOptions(that, name, userOptions, localOptions);
+        // TODO: Does mergeComponentOptions already do too much? It will notify the instantiator based on unpacking the construct record
+        // It *does* compute distributeOptions which is essential for evaluating the meaning of shells everywhere
+        var mergeOptions = fluid.mergeComponentOptions(that, potentia, lightMerge);
         mergeOptions.exceptions = {members: {model: true, modelRelay: true}}; // don't evaluate these in "early flooding" - they must be fetched explicitly
-        var options = that.options;
-        that.events = {};
-        // deliver to a non-IoC side early receiver of the component (currently only initView)
-        (receiver || fluid.identity)(that, options, mergeOptions.strategy);
+        return that;
+    };
+
+    fluid.concludeComponentInit = function (that, shadow) {
+        var mergeOptions = shadow.mergeOptions;
+        fluid.pushActivity("concludeComponentInit", "constructing component of type %componentName at path %path",
+            {componentName: that.typeName, path: shadow.path});
+      
         fluid.computeDynamicComponents(that, mergeOptions);
 
         // TODO: ****THIS**** is the point we must deliver and suspend!! Construct the "component skeleton" first, and then continue
@@ -2646,22 +2616,27 @@ var fluid = fluid || fluid_3_0_0;
             mergeOptions.mergeBlocks[i].initter();
         }
         mergeOptions.initter();
-        delete options.mergePolicy;
-
-        fluid.instantiateFirers(that, options);
-        fluid.mergeListeners(that, that.events, options.listeners);
+        delete that.options.mergePolicy; // silly "optimisation" - make this immutable instead
 
-        return that;
-    };
+        that.events = {};
+        // TODO: Make a recordStrategy for this
+        fluid.instantiateFirers(that, that.options);
+        fluid.mergeListeners(that, that.events, that.options.listeners);
+        // TODO: Decrement any count for pendingSubcomponents in parent component
 
-    fluid.diagnoseFailedView = fluid.identity;
+        var errors = fluid.validateListenersImplemented(that);
+        if (errors.length > 0) {
+            fluid.fail(fluid.transform(errors, function (error) {
+                return ["Error constructing component ", that, " - the listener for event " + error.name + " with namespace " + error.namespace + (
+                    (error.componentSource ? " which was defined in grade " + error.componentSource : "") + " needs to be overridden with a concrete implementation")];
+            })).join("\n");
+        }
+        fluid.initDependents(that);
+        
+        that.events.onCreate.fire(that);
+        fluid.popActivity();
 
-    // unsupported, NON-API function
-    fluid.makeRootDestroy = function (that) {
-        return function () {
-            fluid.doDestroy(that);
-            fluid.fireEvent(that, "afterDestroy", [that, "", null]);
-        };
+        return that;
     };
 
     /** Returns <code>true</code> if the supplied reference holds a component which has been destroyed **/
@@ -2670,48 +2645,32 @@ var fluid = fluid || fluid_3_0_0;
         return that.lifecycleStatus === "destroyed";
     };
 
-    // unsupported, NON-API function
-    fluid.doDestroy = function (that, name, parent) {
-        fluid.fireEvent(that, "onDestroy", [that, name || "", parent]);
-        that.lifecycleStatus = "destroyed";
-        for (var key in that.events) {
-            if (key !== "afterDestroy" && typeof(that.events[key].destroy) === "function") {
-                that.events[key].destroy();
-            }
-        }
-        if (that.applier) { // TODO: Break this out into the grade's destroyer
-            that.applier.destroy();
-        }
+    // Computes a name for a component appearing at the global root which is globally unique, from its nickName and id
+    fluid.computeGlobalMemberName = function (type, id) {
+        var nickName = fluid.computeNickName(type);
+        return nickName + "-" + id;
     };
 
     // unsupported, NON-API function
-    fluid.initComponent = function (componentName, initArgs) {
-        var options = fluid.defaults(componentName);
-        if (!options.gradeNames) {
-            fluid.fail("Cannot initialise component " + componentName + " which has no gradeName registered");
-        }
-        var args = [componentName].concat(fluid.makeArray(initArgs));
-        var that;
-        fluid.pushActivity("initComponent", "constructing component of type %componentName with arguments %initArgs",
-            {componentName: componentName, initArgs: initArgs});
-        that = fluid.invokeGlobalFunction(options.initFunction, args);
-        fluid.diagnoseFailedView(componentName, that, options, args);
-        if (fluid.initDependents) {
-            fluid.initDependents(that);
-        }
-        var errors = fluid.validateListenersImplemented(that);
-        if (errors.length > 0) {
-            fluid.fail(fluid.transform(errors, function (error) {
-                return ["Error constructing component ", that, " - the listener for event " + error.name + " with namespace " + error.namespace + (
-                    (error.componentSource ? " which was defined in grade " + error.componentSource : "") + " needs to be overridden with a concrete implementation")];
-            })).join("\n");
-        }
-        if (that.lifecycleStatus === "constructing") {
-            that.lifecycleStatus = "constructed";
-        }
-        that.events.onCreate.fire(that);
-        fluid.popActivity();
-        return that;
+    // After some error checking, this *is* the component creator function
+    fluid.initFreeComponent = function (type, initArgs) {
+        var id = fluid.allocateGuid();
+        var path = [fluid.computeGlobalMemberName(type, id)];
+        // Special potentia form for free components which has pre-computed id in order to compute path, but
+        // has not yet computed "options" since this cannot be known until we have determined component grade
+        var potentia = {
+            type: "create",
+            path: path,
+            record: {
+                id: id,
+                type: type,
+                initArgs: initArgs
+            }
+        };
+        var transactionId = fluid.registerPotentia(potentia);
+        fluid.commitPotentiae(transactionId);
+
+        return fluid.componentForPath(path);
     };
 
     // unsupported, NON-API function
diff --git a/src/framework/core/js/FluidDebugging.js b/src/framework/core/js/FluidDebugging.js
index c630b68..63546f2 100644
--- a/src/framework/core/js/FluidDebugging.js
+++ b/src/framework/core/js/FluidDebugging.js
@@ -297,4 +297,55 @@ var fluid = fluid || fluid_3_0_0;
         return togo;
     };
 
+    /** BEGIN IOC DEBUGGING METHODS **/
+    fluid["debugger"] = function () {
+        debugger; // eslint-disable-line no-debugger
+    };
+
+    fluid.defaults("fluid.debuggingProbe", {
+        gradeNames: ["fluid.component"]
+    });
+
+    // probe looks like:
+    // target: {preview other}.listeners.eventName
+    // priority: first/last
+    // func: console.log/fluid.log/fluid.debugger
+    fluid.probeToDistribution = function (probe) {
+        var instantiator = fluid.globalInstantiator;
+        var parsed = fluid.parseContextReference(probe.target);
+        var segs = fluid.model.parseToSegments(parsed.path, instantiator.parseEL, true);
+        if (segs[0] !== "options") {
+            segs.unshift("options"); // compensate for this insanity until we have the great options flattening
+        }
+        var parsedPriority = fluid.parsePriority(probe.priority);
+        if (parsedPriority.constraint && !parsedPriority.constraint.target) {
+            parsedPriority.constraint.target = "authoring";
+        }
+        return {
+            target: "{/ " + parsed.context + "}." + instantiator.composeSegments.apply(null, segs),
+            record: {
+                func: probe.func,
+                funcName: probe.funcName,
+                args: probe.args,
+                priority: fluid.renderPriority(parsedPriority)
+            }
+        };
+    };
+
+    fluid.registerProbes = function (probes) {
+        var probeDistribution = fluid.transform(probes, fluid.probeToDistribution);
+        var memberName = "fluid_debuggingProbe_" + fluid.allocateGuid();
+        fluid.construct([memberName], {
+            type: "fluid.debuggingProbe",
+            distributeOptions: probeDistribution
+        });
+        return memberName;
+    };
+
+    fluid.deregisterProbes = function (probeName) {
+        fluid.destroy([probeName]);
+    };
+
+    /** END IOC DEBUGGING METHODS **/
+
 })(jQuery, fluid_3_0_0);
diff --git a/src/framework/core/js/FluidIoC.js b/src/framework/core/js/FluidIoC.js
index ca6a221..988dbe6 100644
--- a/src/framework/core/js/FluidIoC.js
+++ b/src/framework/core/js/FluidIoC.js
@@ -23,15 +23,13 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
      * completely automated instantiation of declaratively defined
      * component trees */
 
-    // Currently still uses manual traversal - once we ban manually instantiated components,
-    // it will use the instantiator's records instead.
     fluid.visitComponentChildren = function (that, visitor, options, segs) {
         segs = segs || [];
-        for (var name in that) {
+        var shadow = fluid.shadowForComponent(that);
+        shadow.childComponents.forEach(function (name) {
             var component = that[name];
-            // This entire algorithm is primitive and expensive and will be removed once we can abolish manual init components
-            if (!fluid.isComponent(component) || (options.visited && options.visited[component.id])) {
-                continue;
+            if (options.visited && options.visited[component.id]) {
+                return;
             }
             segs.push(name);
             if (options.visited) { // recall that this is here because we may run into a component that has been cross-injected which might otherwise cause cyclicity
@@ -44,7 +42,7 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
                 fluid.visitComponentChildren(component, visitor, options, segs);
             }
             segs.pop();
-        }
+        });
     };
 
     fluid.getContextHash = function (instantiator, that) {
@@ -270,7 +268,7 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
         });
         var parentShadow = shadows[shadows.length - (parentThat ? 1 : 2)];
         var contextHashes = fluid.getMembers(shadows, "contextHash");
-        if (parentThat) { // if called before construction of component from assembleCreatorArguments - NB this path will be abolished/amalgamated
+        if (parentThat) { // if called before construction of component from initComponentShell
             memberNames.push(memberName);
             contextHashes.push(fluid.gradeNamesToHash(gradeNames));
             thatStack.push(that);
@@ -443,8 +441,13 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
         }
     };
 
-    fluid.undistributableOptions = ["gradeNames", "distributeOptions", "argumentMap", "initFunction", "mergePolicy", "progressiveCheckerOptions"]; // automatically added to "exclusions" of every distribution
+    fluid.undistributableOptions = ["gradeNames", "distributeOptions", "argumentMap", "mergePolicy"]; // automatically added to "exclusions" of every distribution
 
+    /* Evaluate the `distributeOptions` block in the options of a component, and mount the distribution in the appropriate
+     * shadow for components yet to be constructed, or else apply it immediately to the merge blocks of any target
+     * which is currently in evaluation.
+     * This occurs early during the evaluation phase of the source component, during `fluid.computeComponentAccessor`
+     */
     fluid.distributeOptions = function (that, optionsStrategy) {
         var thatShadow = fluid.shadowForComponent(that);
         var records = fluid.driveStrategy(that.options, "distributeOptions", optionsStrategy);
@@ -653,6 +656,8 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
         return recordKey + (sourceKey === 0 ? "" : "-" + sourceKey); // TODO: configurable name strategies
     };
 
+    // TODO: Convert to potentia, we need a similar FLUID-6146 mechanism that can ensure that dynamic components
+    // created from the same event are part of the same transaction
     fluid.registerDynamicRecord = function (that, recordKey, sourceKey, record, toCensor) {
         var key = fluid.computeDynamicComponentKey(recordKey, sourceKey);
         var cRecord = fluid.copy(record);
@@ -690,8 +695,10 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
         });
     };
 
-    // Second sequence point for mergeOptions from Fluid.js - here we construct all further
-    // strategies required on the IoC side and mount them into the shadow's getConfig for universal use
+    /* Second sequence point for mergeComponentOptions from Fluid.js - here we construct all further
+     * strategies required on the IoC side and mount them into the shadow's getConfig for universal use
+     * We also evaluate and broadcast any options distributions from the options' `distributeOptions`
+     */
     fluid.computeComponentAccessor = function (that, localRecord) {
         var instantiator = fluid.globalInstantiator;
         var shadow = fluid.shadowForComponent(that);
@@ -703,8 +710,10 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
         shadow.eventStrategyBlock = fluid.recordStrategy(that, options, strategy, "events", fluid.eventFromRecord, ["events"]);
         var eventStrategy = fluid.mountStrategy(["events"], that, shadow.eventStrategyBlock.strategy, ["events"]);
         shadow.memberStrategy = fluid.recordStrategy(that, options, strategy, "members", fluid.memberFromRecord, null, {model: true, modelRelay: true});
-        // NB - ginger strategy handles concrete, rationalise
-        shadow.getConfig = {strategies: [fluid.model.funcResolverStrategy, fluid.makeGingerStrategy(that),
+        // TODO: this is all hugely inefficient since we query every scheme for every path, whereas
+        // we should know perfectly well what kind of scheme there will be for a path, especially once we have resolved
+        // FLUID-5761, FLUID-5244
+        shadow.getConfig = {strategies: [fluid.model.funcResolverStrategy, fluid.makeConcreteStrategy(that),
             optionsStrategy, shadow.invokerStrategy.strategy, shadow.memberStrategy.strategy, eventStrategy]};
 
         fluid.computeDynamicGrades(that, shadow, strategy, shadow.mergeOptions.mergeBlocks);
@@ -731,7 +740,9 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
     };
 
     // About the SHADOW:
-    // Allocated at: instantiator's "recordComponent"
+    // This holds a record of IoC information for each instantiated component.
+    // It is allocated at: instantiator's "recordComponent"
+    // It is destroyed at: instantiator's "clearConcreteComponent"
     // Contents:
     //     path {String} Principal allocated path (point of construction) in tree
     //     that {Component} The component itself
@@ -742,9 +753,10 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
     //     distributions, collectedClearer: Managing options distributions
     //     outDistributions: A list of distributions registered from this component, signalling from distributeOptions to clearDistributions
     //     subcomponentLocal: Signalling local record from computeDynamicComponents to assembleCreatorArguments
-    //     dynamicLocal: Local signalling for dynamic grades
     //     ownScope: A hash of names to components which are in scope from this component - populated in cacheShadowGrades
     //     childrenScope: A hash of names to components which are in scope because they are children of this component (BELOW own ownScope in resolution order)
+    //     potentia: The original potentia record as supplied to registerPotentia
+    //     childComponents: Array of key names for subcomponents
 
     fluid.shadowForComponent = function (component) {
         var instantiator = fluid.getInstantiator(component);
@@ -759,10 +771,8 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
         return fluid.get(component, path, getConfig);
     };
 
-    // An EL segment resolver strategy that will attempt to trigger creation of
-    // components that it discovers along the EL path, if they have been defined but not yet
-    // constructed.
-    fluid.makeGingerStrategy = function (that) {
+    // The EL segment resolver strategy for resolving concrete  
+    fluid.makeConcreteStrategy = function (that) {
         var instantiator = fluid.getInstantiator(that);
         return function (component, thisSeg, index, segs) {
             var atval = component[thisSeg];
@@ -776,25 +786,6 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
             if (atval === undefined && component.hasOwnProperty(thisSeg)) { // avoid recomputing properties that have been explicitly evaluated to undefined
                 return fluid.NO_VALUE;
             }
-            if (atval === undefined) { // pick up components in instantiation here - we can cut this branch by attaching early
-                var parentPath = instantiator.idToShadow[component.id].path;
-                var childPath = instantiator.composePath(parentPath, thisSeg);
-                atval = instantiator.pathToComponent[childPath];
-            }
-            if (atval === undefined) {
-                // TODO: This check is very expensive - once gingerness is stable, we ought to be able to
-                // eagerly compute and cache the value of options.components - check is also incorrect and will miss injections
-                var subRecord = fluid.getForComponent(component, ["options", "components", thisSeg]);
-                if (subRecord) {
-                    if (subRecord.createOnEvent) {
-                        fluid.fail("Error resolving path segment \"" + thisSeg + "\" of path " + segs.join(".") + " since component with record ", subRecord,
-                            " has annotation \"createOnEvent\" - this very likely represents an implementation error. Either alter the reference so it does not " +
-                            " match this component, or alter your workflow to ensure that the component is instantiated by the time this reference resolves");
-                    }
-                    fluid.initDependent(component, thisSeg);
-                    atval = component[thisSeg];
-                }
-            }
             return atval;
         };
     };
@@ -938,6 +929,25 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
             }
         });
     };
+    
+    // unsupported, NON-API function
+    fluid.doDestroy = function (that, name, parent) {
+        fluid.fireEvent(that, "onDestroy", [that, name || "", parent]);
+        that.lifecycleStatus = "destroyed";
+        for (var key in that.events) {
+            if (key !== "afterDestroy" && typeof(that.events[key].destroy) === "function") {
+                that.events[key].destroy();
+            }
+        }
+        if (that.applier) { // TODO: Break this out into the grade's destroyer
+            that.applier.destroy();
+        }
+    };
+   
+    // potentia II records look a lot like change records - 
+    // action: "create"/"destroy"
+    // record: { type: "componentType", etc.}
+    // complete: true
 
     // unsupported, non-API function - however, this structure is of considerable interest to those debugging
     // into IoC issues. The structures idToShadow and pathToComponent contain a complete map of the component tree
@@ -949,6 +959,11 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
             pathToComponent: {},
             idToShadow: {},
             modelTransactions: {init: {}}, // a map of transaction id to map of component id to records of components enlisted in a current model initialisation transaction
+            treeTransactions: {}, // a map of transaction id to: {
+                // pathToPotentia: an aligned map of component paths to "potentia II records" 
+                // pendingPotentia: an array of the segs for pathToPotentia which remain to be handled
+            // }
+            currentTreeTransaction: null, // any instantiation in progress. In the current framework, these are still synchronous
             composePath: fluid.model.composePath, // For speed, we declare that no component's name may contain a period
             composeSegments: fluid.model.composeSegments,
             parseEL: fluid.model.parseEL,
@@ -957,6 +972,10 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
                 onComponentClear: fluid.makeEventFirer({name: "instantiator's onComponentClear event"})
             }
         });
+        // Convenience method for external methods to accept path or segs
+        that.parseToSegments = function (path) {
+            return fluid.model.parseToSegments(path, that.parseEL, true);
+        };
         // TODO: this API can shortly be removed
         that.idToPath = function (id) {
             var shadow = that.idToShadow[id];
@@ -1028,15 +1047,17 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
             }
         };
         that.clearConcreteComponent = function (record) {
+            var shadow = record.childShadow;
             // Clear injected instance of this component from all other paths - historically we didn't bother
             // to do this since injecting into a shorter scope is an error - but now we have resolveRoot area
-            fluid.each(record.childShadow.injectedPaths, function (troo, injectedPath) {
+            fluid.each(shadow.injectedPaths, function (troo, injectedPath) {
                 var parentPath = fluid.model.getToTailPath(injectedPath);
                 var otherParent = that.pathToComponent[parentPath];
                 that.clearComponent(otherParent, fluid.model.getTailPath(injectedPath), record.child);
             });
-            fluid.clearDistributions(record.childShadow);
-            fluid.clearListeners(record.childShadow);
+            fluid.each(shadow.
+            fluid.clearDistributions(shadow);
+            fluid.clearListeners(shadow);
             fluid.fireEvent(record.child, "afterDestroy", [record.child, record.name, record.component]);
             delete that.idToShadow[record.child.id];
         };
@@ -1152,16 +1173,18 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
         return expanded;
     };
 
-    fluid.localRecordExpected = fluid.arrayToHash(["type", "options", "container", "createOnEvent", "priority", "recordType"]); // last element unavoidably polluting
+    fluid.subcomponentRecordExpected = fluid.arrayToHash(["type", "options", "container", "createOnEvent", "priority"]); // last element unavoidably polluting
 
     fluid.checkComponentRecord = function (localRecord) {
-        fluid.each(localRecord, function (value, key) {
-            if (!fluid.localRecordExpected[key]) {
-                fluid.fail("Probable error in subcomponent record ", localRecord, " - key \"" + key +
-                    "\" found, where the only legal options are " +
-                    fluid.keys(fluid.localRecordExpected).join(", "));
-            }
-        });
+        if (!fluid.isPrimitive(localRecord)) {
+            fluid.each(localRecord, function (value, key) {
+                if (!fluid.subcomponentRecordExpected[key]) {
+                    fluid.fail("Probable error in subcomponent record ", localRecord, " - key \"" + key +
+                        "\" found, where the only legal options are " +
+                        fluid.keys(fluid.subcomponentRecordExpected).join(", "));
+                }
+            });
+        }
     };
 
     fluid.mergeRecordsToList = function (that, mergeRecords) {
@@ -1204,66 +1227,68 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
     };
 
     var expandComponentOptionsImpl = function (mergePolicy, defaults, initRecord, that) {
-        var defaultCopy = fluid.copy(defaults);
-        addPolicyBuiltins(mergePolicy);
-        var shadow = fluid.shadowForComponent(that);
-        shadow.mergePolicy = mergePolicy;
-        var mergeRecords = {
-            defaults: {options: defaultCopy}
-        };
-
-        $.extend(mergeRecords, initRecord.mergeRecords);
-        // Do this here for gradeless components that were corrected by "localOptions"
-        if (mergeRecords.subcomponentRecord) {
-            fluid.checkComponentRecord(mergeRecords.subcomponentRecord);
-        }
-
-        var expandList = fluid.mergeRecordsToList(that, mergeRecords);
 
-        var togo = fluid.transform(expandList, function (value) {
-            return fluid.generateExpandBlock(value, that, mergePolicy, initRecord.localRecord);
-        });
-        return togo;
     };
 
     fluid.fabricateDestroyMethod = function (that, name, instantiator, child) {
         return function () {
-            instantiator.clearComponent(that, name, child);
+            var shadow = fluid.shadowForComponent(that);
+            fluid.destroy(shadow.path);
+            // instantiator.clearComponent(that, name, child);
         };
     };
 
-    // Computes a name for a component appearing at the global root which is globally unique, from its nickName and id
-    fluid.computeGlobalMemberName = function (that) {
-        var nickName = fluid.computeNickName(that.typeName);
-        return nickName + "-" + that.id;
-    };
-
     // Maps a type name to the member name to be used for it at a particular path level where it is intended to be unique
     // Note that "." is still not supported within a member name
     // supported, PUBLIC API function
     fluid.typeNameToMemberName = function (typeName) {
         return typeName.replace(/\./g, "_");
     };
+    
+    fluid.pushMergeRecord = function (mergeRecords, options, recordType, priorityDelta) {
+        mergeRecords.push({
+            options: options,
+            recordType: recordType,
+            priorityDelta: priorityDelta || 0
+        });
+    };
 
     // This is the initial entry point from the non-IoC side reporting the first presence of a new component - called from fluid.mergeComponentOptions
-    fluid.expandComponentOptions = function (mergePolicy, defaults, userOptions, that) {
-        var initRecord = userOptions; // might have been tunnelled through "userOptions" from "assembleCreatorArguments"
-        var instantiator = userOptions && userOptions.marker === fluid.EXPAND ? userOptions.instantiator : null;
-        fluid.pushActivity("expandComponentOptions", "expanding component options %options with record %record for component %that",
-            {options: instantiator ? userOptions.mergeRecords.user : userOptions, record: initRecord, that: that});
-        if (!instantiator) { // it is a top-level component which needs to be attached to the global root
-            instantiator = fluid.globalInstantiator;
-            initRecord = { // upgrade "userOptions" to the same format produced by fluid.assembleCreatorArguments via the subcomponent route
-                mergeRecords: {user: {options: fluid.expandCompact(userOptions, true)}},
-                memberName: fluid.computeGlobalMemberName(that),
-                instantiator: instantiator,
-                parentThat: fluid.rootComponent
-            };
+    // Returns an array of mergeBlocks
+    fluid.expandComponentOptions = function (mergePolicy, defaults, potentia, lightMerge, that) {
+        // TODO: Once we stabilise, experiment with not copying this already immutable record
+        var defaultCopy = fluid.copy(defaults);
+        var mergeRecords = lightMerge.toMerge;
+        fluid.pushMergeRecord(mergeRecords, defaultCopy, "defaults");
+
+        if (potentia.initArgs) {
+            var record = {};
+            fluid.each(defaults.argumentMap, function (index, name) {
+                record[name] = record.initArgs[index];
+            });
+            fluid.pushMergeRecord(mergeRecords, fluid.expandCompact(record.options, true), "user");
         }
-        that.destroy = fluid.fabricateDestroyMethod(initRecord.parentThat, initRecord.memberName, instantiator, that);
+        // hoist out "container" to be an option - eliminate this after FLUID-5750
+        if (record.container) {
+            fluid.pushMergeRecord(mergeRecords, {
+                    container: record.container
+                }, "user", 1);
+        }
+          
+        that.destroy = fluid.fabricateDestroyMethod(potentia.parentThat, potentia.memberName, instantiator, that);
+        instantiator.recordKnownComponent(potentia.parentThat, that, potentia.memberName, true);
+
+        addPolicyBuiltins(mergePolicy);
+        var shadow = fluid.shadowForComponent(that);
+        shadow.mergePolicy = mergePolicy;
+
+        // TODO: We are here - work out which format mergeRecords are all in and in what order - note that initComponentShell
+        // already called computeDistributionPriority so we should be able to axe mergeRecordsToList
+        var expandList = fluid.mergeRecordsToList(that, mergeRecords);
 
-        instantiator.recordKnownComponent(initRecord.parentThat, that, initRecord.memberName, true);
-        var togo = expandComponentOptionsImpl(mergePolicy, defaults, initRecord, that);
+        var togo = fluid.transform(expandList, function (value) {
+            return fluid.generateExpandBlock(value, that, mergePolicy, potentia.localRecord);
+        });
 
         fluid.popActivity();
         return togo;
@@ -1274,21 +1299,14 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
      * and argument list which is suitable to be executed directly by fluid.invokeGlobalFunction.
      */
     // options is just a disposition record containing memberName, componentRecord
+    // TODO also "localDynamic" it seems, which is then used to compute "localRecord"
+    // TODO: We will no longer construct subcomponents via invoking their driver functions, but instead split up the
+    // process of "initDependent" in order to push to simply push to potentia
     fluid.assembleCreatorArguments = function (parentThat, typeName, options) {
-        var upDefaults = fluid.defaults(typeName); // we're not responsive to dynamic changes in argMap, but we don't believe in these anyway
-        if (!upDefaults || !upDefaults.argumentMap) {
-            fluid.fail("Error in assembleCreatorArguments: cannot look up component type name " + typeName + " to a component creator grade with an argumentMap");
-        }
 
+        // TODO: "fakeThat" will no longer be required since we will always have a real one
         var fakeThat = {}; // fake "that" for receiveDistributions since we try to match selectors before creation for FLUID-5013
-        var distributions = parentThat ? fluid.receiveDistributions(parentThat, upDefaults.gradeNames, options.memberName, fakeThat) : [];
-        fluid.each(distributions, function (distribution) { // TODO: The duplicated route for this is in fluid.mergeComponentOptions
-            fluid.computeDistributionPriority(parentThat, distribution);
-            if (fluid.isPrimitive(distribution.priority)) { // TODO: These should be immutable and parsed just once on registration - but we can't because of crazy target-dependent distance system
-                distribution.priority = fluid.parsePriority(distribution.priority, 0, false, "options distribution");
-            }
-        });
-        fluid.sortByPriority(distributions);
+
 
         var localDynamic = options.localDynamic;
         var localRecord = $.extend({}, fluid.censorKeys(options.componentRecord, ["type"]), localDynamic);
@@ -1318,6 +1336,7 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
         fluid.each(argMap, function (index, name) {
             var arg;
             if (name === "options") {
+                // TODO: This "care package" can now be unmarkerified - the component creator function will assemble a matching one always
                 arg = {marker: fluid.EXPAND,
                            localRecord: localDynamic,
                            mergeRecords: mergeRecords,
@@ -1325,6 +1344,7 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
                            parentThat: parentThat,
                            memberName: options.memberName};
             } else {
+                // The only other possibility for this was always just "container"
                 var value = localRecord[name];
                 arg = fluid.expandImmediate(value, parentThat, localRecord);
             }
@@ -1338,10 +1358,8 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
         return togo;
     };
 
-    /** Instantiate the subcomponent with the supplied name of the supplied top-level component. Although this method
-     * is published as part of the Fluid API, it should not be called by general users and may not remain stable. It is
-     * currently the only mechanism provided for instantiating components whose definitions are dynamic, and will be
-     * replaced in time by dedicated declarative framework described by FLUID-5022.
+    /** Instantiate the subcomponent with the supplied name of the supplied top-level component. This method is no longer
+     * (as of Infusion 3.0) a part of the public API
      * @param that {Component} the parent component for which the subcomponent is to be instantiated
      * @param name {String} the name of the component - the index of the options block which configures it as part of the
      * <code>components</code> section of its parent's options
@@ -1381,8 +1399,8 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
         return instance;
     };
 
-    fluid.bindDeferredComponent = function (that, componentName, component) {
-        var events = fluid.makeArray(component.createOnEvent);
+    fluid.bindDeferredComponent = function (that, componentName, componentSpec) {
+        var events = fluid.makeArray(componentSpec.createOnEvent);
         fluid.each(events, function (eventName) {
             var event = fluid.isIoCReference(eventName) ? fluid.expandOptions(eventName, that) : that.events[eventName];
             if (!event || !event.addListener) {
@@ -1390,25 +1408,23 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
                     eventName + " could not be expanded to an event - got ", event);
             }
             event.addListener(function () {
+                // TODO: This is where we perform the complex FLUID-6146 activity of opening a transaction on the first
+                // listener and then adding some kind of "global last" listener which commits it
                 fluid.pushActivity("initDeferred", "instantiating deferred component %componentName of parent %that due to event %eventName",
                  {componentName: componentName, that: that, eventName: eventName});
                 if (that[componentName]) {
                     fluid.globalInstantiator.clearComponent(that, componentName);
                 }
                 var localRecord = {"arguments": fluid.makeArray(arguments)};
+                // TODO: This becomes a registerPotentia etc.
                 fluid.initDependent(that, componentName, localRecord);
                 fluid.popActivity();
-            }, null, component.priority);
+            });
         });
     };
 
-    fluid.priorityForComponent = function (component) {
-        return component.priority ? component.priority :
-            (component.type === "fluid.typeFount" || fluid.hasGrade(fluid.defaults(component.type), "fluid.typeFount")) ?
-            "first" : undefined;
-    };
-
-    fluid.initDependents = function (that) {
+    // TODO: This is currently triggered by old "initComponent" - instead, we need a transRec!
+    fluid.initDependents = function (that, transRec) {
         fluid.pushActivity("initDependents", "instantiating dependent components for component %that", {that: that});
         var shadow = fluid.shadowForComponent(that);
         shadow.memberStrategy.initter();
@@ -1420,23 +1436,21 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
             return; // Further fix for FLUID-5869 - if we managed to destroy ourselves through some bizarre model self-reaction, bail out here
         }
 
-        var options = that.options;
-        var components = options.components || {};
-        var componentSort = [];
+        var segs = fluid.pathForComponent(that);
+        var potentiae = fluid.fetchPathedPotentiae(transRec, segs);
 
-        fluid.each(components, function (component, name) {
-            if (!component.createOnEvent) {
-                var priority = fluid.priorityForComponent(component);
-                componentSort.push({namespace: name, priority: fluid.parsePriority(priority)});
-            }
-            else {
-                fluid.bindDeferredComponent(that, name, component);
+        fluid.each(potentiae, function (holders, name) {
+            if (name !== "*") {
+                var componentSpec = fluid.mergeSubcomponentPotentiae(holders["*"]);
+                if (!componentSpec.createOnEvent) {
+                    fluid.initDependent(that, entry.name);
+                }
+                else {
+                    fluid.bindDeferredComponent(that, name, componentSpec);
+                }
             }
         });
-        fluid.sortByPriority(componentSort);
-        fluid.each(componentSort, function (entry) {
-            fluid.initDependent(that, entry.namespace);
-        });
+
         if (shadow.subcomponentLocal) {
             fluid.clear(shadow.subcomponentLocal); // still need repo for event-driven dynamic components - abolish these in time
         }
@@ -1488,20 +1502,212 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
         return instantiator.parseEL(shadow.path);
     };
 
+    fluid.fetchPathedPotentiae = function (transRec, segs) {
+        var holder = fluid.getImmediate(transRec.pathToPotentiae, segs);
+        if (!holder) {
+            holder = {
+                "*": []
+            }
+            fluid.set(transRec.pathToPotentiae, segs, holder);
+        }
+        // Similar nutty scheme as for encoding mergePolicies
+        if (!holder["*"]) {
+            holder["*"] = [];
+        }
+        return holder["*"];
+    };
+
+    /** Signature as for fluid.construct. Registers the intention of constructing or destroying a component at a particular path. The action will
+     * occur once the transaction is committed.
+     * @param potentia {Object} A record designating the kind of change to occur. Fields:
+     *    type: {String} Either "create" or "destroy".
+     *    path: {String|Array of String} Path where the component is to be constructed or destroyed, represented as a string or array of segments
+     *    componentDepth: {Number} The depth of nesting of this record from the originally created component - defaults to 0
+     *    record: {Object} A component's construction record, as they would currently appear in a component's "options.components.x" record
+     *        In the case of a free component instantiation, record instead contains a member `initArgs` holding the original arguments sent to
+     *        the component's creator function
+     * @param transactionId {String} [optional] A transaction id in which to enlist this registration. If this is omitted, the current transaction
+     * will be used, if there is one - otherwise, a fresh transaction will be allocated 
+     * @return {String} The id of the transaction used for this registration
+     */
+    fluid.registerPotentia = function (potentia, transactionId) {
+        var instantiator = fluid.globalInstantiator;
+        transactionId = transactionId || instantiator.currentTreeTransaction || fluid.allocateGuid();
+        
+        var transRec = instantiator.treeTransactions[transactionId];
+        if (!transRec) {
+            transRec = instantiator.treeTransactions[transactionId] = {
+                pathToPotentiae: {}, // aligned map of component paths to "potentia II records"
+                pendingPotentiae: [], // array of potentia which remain to be handled
+                restoreRecords: [] // accumulate a list of records to be executed in case the transaction is backed out
+            };
+        }
+        var segs = potentia.segs = potentia.segs || instantiator.parseToSegments(potentia.path);
+        var pathToPotentiae = fluid.fetchPathedPotentiae(transRec, segs);
+        pathToPotentiae.push(potentia);
+        transRec.pendingPotentiae.push(potentia);
+        return transactionId;
+    };
+    
+    fluid.isInjectedComponentRecord = function (record) {
+        return typeof(record) === "string" || record.expander;
+    };
+    
+    fluid.lightMergeRecords = function (records) {
+        var type, toMerge, isInjected;
+        records.forEach(function (record) {
+            if (fluid.isInjectedComponentRecord) {
+                toMerge = [record];
+                isInjected = true;
+            } else {
+                type = record.type;
+                if (isInjected) {
+                    toMerge = [record];
+                } else {
+                    toMerge.push(record);
+                }
+                isinjected = false;
+            }
+        });
+        return {
+            type: type,
+            toMerge: toMerge,
+            isInjected: isInjected
+        };
+    }
+    
+    // Begin the action of creating a component - register its shell and mergeOptions at the correct site, and evaluate
+    // and scan options for its child components, recursively registering them
+    fluid.operateCreatePotentia = function (transRec, potentia, instantiator) {
+        var instantiator = instantiator || fluid.globalInstantiator;
+        // TODO: currently this overall workflow is synchronous and so we have no risk. In future, asynchronous
+        // transactions imply that the same path may receive a component from two different transactions - therefore
+        // we will need to pass the transaction along to these methods and allocate the components themselves within
+        // the transRec and only commit them if they are conflict-free (a la Kulkarni)
+        var records = potentia.records,
+            name = potentia.memberName,
+            parentThat = potentia.parentThat;
+
+        fluid.pushActivity("operateCreatePotentia", "operating create potentia for path \"%path\" with records %records",
+            {path: potentia.path, record: potentia.records});
+
+        var lightMerge = fluid.lightMergeRecords(potentia.records);
+        if (lightMerge.isInjected) {
+            parentThat[name] = fluid.inEvaluationMarker;
+            instance = fluid.expandImmediate(lightMerge.toMerge[0], parentThat);
+            if (instance) {
+                instantiator.recordKnownComponent(parentThat, instance, name, false);
+            } else {
+                // TODO: We assume this should be a no-op since we would have just operated a destroy potentia if there was something here
+                // delete that[name];
+            }
+        } else if (lightMerge.type) {
+            var shell = fluid.initComponentShell(potentia, lightMerge.toMerge);
+            var shadow = instantiator.idToShadow[shell.id];
+            shadow.potentia = potentia;
+    
+            var mergeOptions = shadow.mergeOptions;
+            var componentDepth = potentia.componentDepth || 0;
+            var components = fluid.driveStrategy(that.options, "components", mergeOptions.strategy);
+            shadow.childComponents = Object.keys(components);
+            fluid.each(components, function (subcomponentRecord, key) {
+                fluid.checkComponentRecord(subcomponentRecord);
+                var newSegs = potentia.segs.concat([key]);
+                var subPotentia = {
+                    type: "create",
+                    segs: newSegs,
+                    componentDepth: componentDepth + 1,
+                    sourceComponentId: shell.id,
+                    record: subcomponentRecord
+                };
+                fluid.registerPotentia(subPotentia);
+            });
+        } else {
+            fluid.fail("Unrecognised material in place of subcomponent " + name + " - could not recognise the records ",
+                potentia.records, " as designating either an injected or concrete component");
+        }
+
+        transRec.restoreRecords.unshift({
+            type: "delete",
+            segs: potentia.segs
+        });
+        fluid.popActivity();
+    };
+    
+    fluid.operateDestroyPotentia = function (transRec, potentia, instantiator) {
+        var instantiator = instantiator || fluid.globalInstantiator;
+        var that = fluid.getImmediate(fluid.rootComponent, potentia.segs);
+        if (that) {
+            var shadow = fluid.shadowForComponent(that);
+            instantiator.clearComponent(potentia.parentThat, potentia.memberName, that);
+            // Store the record that if this transaction is cancelled, the potentia which constructed this component
+            // should be used to recreate it
+            transRec.restoreRecords.unshift(shadow.potentia);
+        }
+    };
+    
+    fluid.commitPotentiae = function (transactionId, instantiator) {
+        instantiator = instantiator || fluid.globalInstantiator;
+        var transRec = instantiator.treeTransactions[transactionId];
+        var creationPaths = [];
+        try {
+            instantiator.currentTreeTransaction = transactionId;
+            while (transRec.pendingPotentiae.length > 0) {
+                var potentia = transRec.pendingPotentiae.shift();
+                var segs = instantiator.parseToSegments(potentia.path);
+                potentia.segs = segs;
+                potentia.memberName = segs[segs.length - 1];
+                potentia.parentThat = fluid.getImmediate(fluid.rootComponent, segs.slice(-1));
+                if (potentia.type === "create") {
+                    fluid.operateCreatePotentia(transRec, potentia);
+                    creationPaths.push(potentia.segs);
+                } else if (potentia.type === "delete") {
+                    fluid.operateDestroyPotentia(transRec, potentia);
+                }
+            };
+            creationPaths.forEach(function (creationPath) {
+                var shell = fluid.getImmediate(fluid.rootComponent, creationPath);
+                var shadow = instantiator.idToShadow[shell.id];
+                fluid.concludeComponentInit(shell, shadow);
+            });
+            instantiator.currentTreeTransaction = null;
+        } catch (e) {
+            fluid.cancelTransaction(transRec, instantiator);
+            throw e;
+        } finally {
+            instantiator.currentTreeTransaction = null;
+            delete instantiator.treeTransactions[transactionId]
+        }
+    };
+
     /** Construct a component with the supplied options at the specified path in the component tree. The parent path of the location must already be a component.
      * @param path {String|Array of String} Path where the new component is to be constructed, represented as a string or array of segments
      * @param options {Object} Top-level options supplied to the component - must at the very least include a field <code>type</code> holding the component's type
      * @param instantiator {Instantiator} [optional] The instantiator holding the component to be created - if blank, the global instantiator will be used
      */
     fluid.construct = function (path, options, instantiator) {
-        var record = fluid.destroy(path, instantiator);
-        // TODO: We must construct a more principled scheme for designating child components than this - especially once options become immutable
-        fluid.set(record.parent, ["options", "components", record.memberName], {
-            type: options.type,
-            options: options
+        var transactionId = fluid.registerPotentia({
+            path: path,
+            action: "destroy",
         });
-        return fluid.initDependent(record.parent, record.memberName);
-    };
+        var record = {
+            type: "user"
+        };
+        var potentia = {
+            path: path,
+            action: "create",
+            records: [record]
+        };
+        // Courtesy to restructure record before one day we have FLUID-5750 options flattening
+        fluid.each(fluid.subcomponentRecordExpected, function (troo, key) {
+            if (options[key] !== undefined) {
+                record[key] = options[key];
+            }
+        });
+        record.options = options;
+        fluid.registerPotentia(potentia, transactionId);
+        fluid.commitPotentiae(transactionId);
+    }; 
 
     /** Destroys a component held at the specified path. The parent path must represent a component, although the component itself may be nonexistent
      * @param path {String|Array of String} Path where the new component is to be destroyed, represented as a string or array of segments
@@ -1509,22 +1715,15 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
      */
     fluid.destroy = function (path, instantiator) {
         instantiator = instantiator || fluid.globalInstantiator;
-        var segs = fluid.model.parseToSegments(path, instantiator.parseEL, true);
+        var segs = instantiator.parseToSegments(path);
         if (segs.length === 0) {
             fluid.fail("Cannot destroy the root component");
         }
-        var memberName = segs.pop(), parentPath = instantiator.composeSegments.apply(null, segs);
-        var parent = instantiator.pathToComponent[parentPath];
-        if (!parent) {
-            fluid.fail("Cannot modify component with nonexistent parent at path ", path);
-        }
-        if (parent[memberName]) {
-            parent[memberName].destroy();
-        }
-        return {
-            parent: parent,
-            memberName: memberName
-        };
+        var transactionId = fluid.registerPotentia({
+            path: path,
+            action: "destroy",
+        });
+        return fluid.commitPotentiae(transactionId);        
     };
 
    /** Construct an instance of a component as a child of the specified parent, with a well-known, unique name derived from its typeName
@@ -1596,57 +1795,6 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
 
     /** END NEXUS METHODS **/
 
-    /** BEGIN IOC DEBUGGING METHODS **/
-    fluid["debugger"] = function () {
-        debugger; // eslint-disable-line no-debugger
-    };
-
-    fluid.defaults("fluid.debuggingProbe", {
-        gradeNames: ["fluid.component"]
-    });
-
-    // probe looks like:
-    // target: {preview other}.listeners.eventName
-    // priority: first/last
-    // func: console.log/fluid.log/fluid.debugger
-    fluid.probeToDistribution = function (probe) {
-        var instantiator = fluid.globalInstantiator;
-        var parsed = fluid.parseContextReference(probe.target);
-        var segs = fluid.model.parseToSegments(parsed.path, instantiator.parseEL, true);
-        if (segs[0] !== "options") {
-            segs.unshift("options"); // compensate for this insanity until we have the great options flattening
-        }
-        var parsedPriority = fluid.parsePriority(probe.priority);
-        if (parsedPriority.constraint && !parsedPriority.constraint.target) {
-            parsedPriority.constraint.target = "authoring";
-        }
-        return {
-            target: "{/ " + parsed.context + "}." + instantiator.composeSegments.apply(null, segs),
-            record: {
-                func: probe.func,
-                funcName: probe.funcName,
-                args: probe.args,
-                priority: fluid.renderPriority(parsedPriority)
-            }
-        };
-    };
-
-    fluid.registerProbes = function (probes) {
-        var probeDistribution = fluid.transform(probes, fluid.probeToDistribution);
-        var memberName = "fluid_debuggingProbe_" + fluid.allocateGuid();
-        fluid.construct([memberName], {
-            type: "fluid.debuggingProbe",
-            distributeOptions: probeDistribution
-        });
-        return memberName;
-    };
-
-    fluid.deregisterProbes = function (probeName) {
-        fluid.destroy([probeName]);
-    };
-
-    /** END IOC DEBUGGING METHODS **/
-
     fluid.thisistToApplicable = function (record, recthis, that) {
         return {
             apply: function (noThis, args) {
diff --git a/src/framework/core/js/FluidView.js b/src/framework/core/js/FluidView.js
index d6edf98..18bfbe1 100644
--- a/src/framework/core/js/FluidView.js
+++ b/src/framework/core/js/FluidView.js
@@ -38,26 +38,6 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
             selectable.selector ? selectable.selector : "";
     };
 
-    // unsupported, NON-API function
-    // NOTE: this function represents a temporary strategy until we have more integrated IoC debugging.
-    // It preserves the 1.3 and previous framework behaviour for the 1.x releases, but provides a more informative
-    // diagnostic - in fact, it is perfectly acceptable for a component's creator to return no value and
-    // the failure is really in assumptions in fluid.initLittleComponent. Revisit this issue for 2.0
-    fluid.diagnoseFailedView = function (componentName, that, options, args) {
-        if (!that && fluid.hasGrade(options, "fluid.viewComponent")) {
-            var container = fluid.wrap(args[1]);
-            var message1 = "Instantiation of view component with type " + componentName + " failed, since ";
-            if (!container) {
-                fluid.fail(message1 + " container argument is empty");
-            }
-            else if (container.length === 0) {
-                fluid.fail(message1 + "selector \"", fluid.dumpSelector(args[1]), "\" did not match any markup in the document");
-            } else {
-                fluid.fail(message1 + " component creator function did not return a value");
-            }
-        }
-    };
-
     fluid.checkTryCatchParameter = function () {
         var location = window.location || { search: "", protocol: "file:" };
         var GETparams = location.search.slice(1).split("&");
@@ -101,6 +81,9 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
      * @return a single-element jQuery of container
      */
     fluid.container = function (containerSpec, fallible, userJQuery) {
+        if (!containerSpec) {
+            fluid.fail("fluid.container argument is empty");
+        }
         var selector = containerSpec.selector || containerSpec;
         if (userJQuery) {
             containerSpec = fluid.unwrap(containerSpec);
@@ -141,7 +124,6 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
      * @param {Object} selectors a collection of named jQuery selectors
      */
     fluid.createDomBinder = function (container, selectors) {
-        // don't put on a typename to avoid confusing primitive visitComponentChildren
         var that = {
             id: fluid.allocateGuid(),
             cache: {}
@@ -251,6 +233,7 @@ var fluid_3_0_0 = fluid_3_0_0 || {};
         var receiver = function (that) {
             that.container = container;
         };
+        // THIS is the only point localOptions was used - now trashed
         var that = fluid.initLittleComponent(componentName, userOptions, localOptions || {gradeNames: ["fluid.viewComponent"]}, receiver);
 
         if (!that.dom) {
